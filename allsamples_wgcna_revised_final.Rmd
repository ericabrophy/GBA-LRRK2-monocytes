---
title: "WGCNA analysis by Erica Brophy"
output:
  html_document:
    df_print: paged
  pdf_document: default
---



```{r message=FALSE, warning=FALSE}
library(edgeR)
library(DT)
library(sva)
library(limma)
library(factoextra)
library(WGCNA)
library(data.table)
library(flashClust)
library(DESeq2)
library(vctrs)
library(tidyverse)
library(broom)
library(rstatix)
library(dplyr)
library(janitor)
library(ggdendro)
library(patchwork)
```

```{r}
#load("/Users/ericabrophy/Documents/allsamples_wgcna_revised_128_274.RData")
```

GENCODE reference
```{r}
gencode <- rtracklayer::import("/Users/ericabrophy/Documents/gencode.v38.primary_assembly.annotation.gtf")
gencode <- as.data.frame(gencode)
gencode_pc <- subset(gencode, select = c('gene_id', 'gene_type'))
gencode_pc <- unique(gencode_pc)
gencode_pc <- filter(gencode_pc, gene_type == "protein_coding")
```

Load in metadata
```{r message=FALSE, warning=FALSE}
meta <- read_tsv("/Users/ericabrophy/Documents/bioPD_data/allmeta_covariates_correctgroups_339.tsv")
meta <- filter(meta, Diagnosis == "PD" | Diagnosis == "Control")
```

Create GBA mutation classification groups
```{r}
meta <- meta %>%
  mutate(groups = case_when(GBA_classification == "Biallelic"  ~ "GBA_PD",
                        GBA_classification == "Risk_variant" ~ "GBA_PD",
                         GBA_classification == "Severe" ~ "GBA_PD",
                        TRUE ~ groups))
```

```{r}
meta <- meta %>%
  mutate(groups = case_when(Sample_id == "NYUMD0091-01"  ~ "GBA_LRRK2_PD",
                            Sample_id == "BIMD0051-01"  ~ "GBA_LRRK2_PD",
                         Sample_id == "BIMD0085-01"  ~ "GBA_LRRK2_PD",
                         Sample_id == "BIMD0231-01"  ~ "GBA_LRRK2_PD",
                         Sample_id == "BIMD0299-01"  ~ "GBA_LRRK2_PD",
                         Sample_id == "BIMD0333-01"  ~ "GBA_LRRK2_PD",
                                                  Sample_id == "BIMD0380-01"  ~ "GBA_LRRK2_PD",
                        TRUE ~ groups))

meta <- meta %>%
   mutate(groups = case_when(Sample_id == "BIMD0115-01"  ~ "GBA_NMC",
                             Sample_id == "BIMD0117-01"  ~ "GBA_NMC",
                          Sample_id == "BIMD0160-01"  ~ "GBA_LRRK2_NMC",
                       TRUE ~ groups))
```

Remove donor BIMD0190-01 (drug induced or does not have PD)
```{r}
meta <- meta[!grepl("BIMD0190", meta$donor_id),]
```

Remove donor BIMD0189-01 (Atypical PD)
```{r}
meta <- meta[!grepl("BIMD0189", meta$donor_id),]
```

Remove NA samples as donors are Sephardic Jewish (SJ)
```{r}
meta <- meta[!is.na(meta$groups),]
```

Remove NMC samples
```{r}
meta <-  filter(meta, groups == "Control" | groups == "GBA_PD" | groups == "LRRK2_PD" | groups == "iPD")
```

Read in count and tpm data
```{r}
counts <- read_tsv("/Users/ericabrophy/Documents/bioPD_data/AJ_counts_339.tsv")
counts <- column_to_rownames(counts, "gene_id")
counts <- counts[,colnames(counts) %in% meta$donor_id]

tpm <- read_tsv("/Users/ericabrophy/Documents/bioPD_data/tpm_339.tsv")
tpm <- column_to_rownames(tpm, "gene_id")
```

Filter by median TPM > 0
```{r}
genes <- rownames(tpm)
median_gene_tpm <- enframe(rowMedians(as.matrix(tpm)), name = "Gene", value = "median_tpm")
median_gene_tpm <- cbind(median_gene_tpm, genes)
keep.exp <- dplyr::filter(median_gene_tpm, median_tpm > 0)
keep.exp <- keep.exp$genes
counts <- counts[keep.exp,]
```


Keep only protein coding genes
```{r}
counts <- counts[rownames(counts) %in% gencode_pc$gene_id,]
```

Subset groups for analysis
```{r}
#selected_meta <- filter(meta, groups == "GBA_PD" | groups == "iPD" )
selected_counts <- counts[,colnames(counts) %in% meta$donor_id]
```

Check indexes match
```{r}
selected_counts <- selected_counts[,meta$donor_id]
identical(colnames(selected_counts), meta$donor_id)
```

PCA before adjustment
```{r}
# Data normalization 
dds <- DESeqDataSetFromMatrix(countData = round(selected_counts),
                             colData = meta,
                             design = ~ groups)
```

```{r}
gExpr <- DGEList(counts=assay(dds))
gExpr <- calcNormFactors(gExpr)
vobjGenes <- voom(gExpr, model.matrix( ~ groups, meta) )
gene_counts_voom = vobjGenes$E # normalized matrix 

res.pca = prcomp(t(gene_counts_voom))
fviz_pca_ind(res.pca, 
             habillage = meta$groups)
```

Estimate number of SVs
```{r}
# SVA network for data adjustment 
mod0 <- model.matrix(~ 1, colData(dds))
mod <- model.matrix(design(dds), colData(dds))
nsv <- num.sv(gene_counts_voom, mod, method = "be")
message(paste0("Number of SVs proposed: ", nsv)) 
nsv <- 11
```

PCA after adjustment
```{r}
resid_expr = sva_network(gene_counts_voom, nsv)
resid_expr <- as.data.frame(resid_expr)# matrix adjusted
resid_expr_t = t(resid_expr)
resid_expr_t <- as.data.frame(resid_expr_t)


res.pca2 = prcomp(resid_expr_t)
fviz_pca_ind(res.pca2,
             habillage = meta$groups)
```

```{r}
# Extract the nsv regressed out 
n.pc = nsv
gene_counts_voom_t = t(gene_counts_voom) 
ss<-svd(gene_counts_voom_t - colMeans(gene_counts_voom_t))
comp_sva = ss$u[,1:n.pc] 
```

Subset metadata
```{r}
meta_sub <- subset(meta, select = c('Age_at_Draw','Sex_reported','clinic','batch','GBA_classification','groups', 'PCT_INTRONIC_BASES', "Diagnosis"))
# This is necessary because of the Pearson correlation calculated in the Heatmap for traits
meta_sub$Sex_reported <- as.numeric(as.factor(meta_sub$Sex_reported))
meta_sub$clinic <- as.numeric(as.factor(meta_sub$clinic))
meta_sub$groups <- as.numeric(as.factor(meta_sub$groups))
meta_sub$GBA_classification <- as.numeric(as.factor(meta_sub$GBA_classification))
meta_sub$Diagnosis <- as.numeric(as.factor(meta_sub$Diagnosis))
meta_sub$batch <- as.numeric(as.factor(meta_sub$batch))

meta_sub <- as.data.frame(meta_sub)
```

Create covariate matrix
```{r}
covariates = c('Age_at_Draw','Sex_reported','clinic','batch','GBA_classification','groups', 'PCT_INTRONIC_BASES', "Diagnosis")

matrix_rsquared = matrix(NA, nrow = length(covariates), ncol = 11) #Number of factors
matrix_pvalue = matrix(NA, nrow = length(covariates), ncol = 11)

for (x in 1:length(covariates)){
  for (y in 1:11){
    matrix_rsquared[x,y] <- summary( lm(comp_sva[,y] ~ meta_sub[,covariates[x]]) )$adj.r.squared
    matrix_pvalue[x,y] <- glance(summary( lm(comp_sva[,y] ~ meta_sub[,covariates[x]]) ))$p.value #To insert pvalues in the heatmap
  }
}

rownames(matrix_rsquared) = tolower(covariates)
rownames(matrix_pvalue) = tolower(covariates) 
#matrix_pvalue = p.adjust(matrix_pvalue, method = "bonferroni")
matrix_pvalue = matrix(p.adjust(as.vector(as.matrix(matrix_pvalue)), method='bonferroni'),ncol=ncol(matrix_pvalue))
matrix_pvalue = formatC(matrix_pvalue, format = "e", digits = 2)


#png(paste0(work_plots, "LinearReg_sva_network_bonf_230s_pvalues.png"), width = 8, height = 10, res = 300, units = "in")
```

```{r}
library(gplots)
heatmap.2(as.matrix(matrix_rsquared), col = colorRampPalette(RColorBrewer::brewer.pal(6,"RdPu"))(40),
          scale="none",
          cellnote = matrix_pvalue,
          notecol="black",
          notecex = .7,
          margins=c(7,12), # ("margin.Y", "margin.X")
          trace='none', 
          dendrogram=c("row"),
          density.info='none', 
          denscol="black",
          breaks = seq(0, 1, length.out = 41),
          Colv = FALSE,
          xlab = "Factors",
          ylab = "Covariates",
          key = TRUE,
          keysize = 2,
          key.xlab = "Adjusted R2",
          key.ylab = NULL,
          key.xtickfun = NULL,
          key.ytickfun = NULL,
          key.par=list()
#          main = "Linear regression between sva_network and covariates"
)
```

Power Threshold
```{r}
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))

# Call the network topology analysis function
sft = pickSoftThreshold(resid_expr_t, powerVector = powers, verbose = 5)
```

Choose lowest possible power term where topology approximately fits a scale free network
```{r}
# Scale-free topology fit index as a function of the soft-thresholding power
cex1 = 0.9

plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red")
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
```

Connectivity
```{r}
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

Tom adjacency
```{r}
softPower = 6

resid_expr_test <- resid_expr_t
#calculates (correlation or distance) network adjacency from expression data
#adjacency1 <- read.csv("/Users/ericabrophy/adjacency.csv")
adjacency = adjacency(resid_expr_test, power = softPower, type = "signed", corFnc = "bicor", corOptions = list(maxPOutliers =0.1))

#Calculation of the topological overlap matrix, and the corresponding dissimilarity, from a given adjacency matrix
TOM = TOMsimilarity(adjacency, TOMType="signed") 
```


```{r}
dissTOM = 1-TOM
geneTree = flashClust(as.dist(dissTOM), method="average")

plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
```

Net params
```{r}
# "We like large modules" - Tutorial, so we set the minimum module size relatively high:
minModuleSize = 30
# Module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, 
                            distM = dissTOM,
                            deepSplit = 3, 
                            pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize);
```

```{r}
clusters_size = data.matrix(table(dynamicMods))
clusters_size = cbind(rownames(clusters_size),clusters_size)
colnames(clusters_size) = c("cluster","size")

# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
clusters_colors = data.matrix(table(dynamicColors))
clusters_colors = cbind(rownames(clusters_colors), clusters_colors)
colnames(clusters_colors) = c("color","size")

mytable = table(dynamicColors)
# as.data.frame(t(as.matrix(unclass(mytable))))
```

Dendrogram colors
```{r}
# Plot the dendrogram and colors underneath
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram and module colors")
```

Number of modules before merge
```{r}
length(unique(dynamicColors))
```
Clustering eigengenes
```{r}
# Calculate eigengenes
MEList = moduleEigengenes(resid_expr_test, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs)
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average")

plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
#We choose a height cut of 0.25, corresponding to correlation of 0.75, to merge
MEDissThres = 0.25
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
```

Merge modules
```{r}
# Call an automatic merging function
merge = mergeCloseModules(resid_expr_test, dynamicColors, cutHeight = MEDissThres, verbose = 3)
```

```{r}
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs
#png(paste0(expr_dir, "/MyND/Merge_modules.png"), width = 16, height = 8, res = 300, units = "in")
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
```

Merged network
```{r}
#### For use of the new MERGED DATA!!! 
# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
# Save module colors and labels for use in subsequent parts
#save(MEs, mergedMEs, moduleColors, geneTree, adjacency, file = paste0(expr_dir, "MyND/WGCNA_monocytes.RData"))
```

Number of modules after merge
```{r}
length(unique(moduleColors))
```
Module-trait heatmap
```{r message=FALSE, warning=FALSE}
metadata_selected2 = meta[,c("Diagnosis", "Sex_reported", "GBA_classification", "Age_at_Draw", "groups", "clinic", "PCT_INTRONIC_BASES")]
metadata_selected2 <- cbind(metadata_selected2, comp_sva)
metadata_selected2$Diagnosis = as.numeric(as.factor(metadata_selected2$Diagnosis))
metadata_selected2$Sex_reported = as.numeric(as.factor(metadata_selected2$Sex_reported))
metadata_selected2$GBA_classification = as.numeric(as.factor(metadata_selected2$GBA_classification))
metadata_selected2$groups = as.numeric(as.factor(metadata_selected2$groups))
metadata_selected2$clinic = as.numeric(as.factor(metadata_selected2$clinic))
metadata_selected2$PCT_INTRONIC_BASES = as.numeric(metadata_selected2$PCT_INTRONIC_BASES)
metadata_selected2$Age_at_Draw <- as.numeric(metadata_selected2$Age_at_Draw)
#metadata_selected2 <- as.numeric(metadata_selected2[,8:19])
nGenes = ncol(resid_expr_test)
nSamples = nrow(resid_expr_test)

# Recalculate MEs with color labels
MEs0 = moduleEigengenes(resid_expr_test, moduleColors)$eigengenes
MEs = orderMEs(MEs0) #Reorder eigenvectors such that similar ones measured by correlation are next to each other
moduleTraitCor = WGCNA::cor(MEs, metadata_selected2, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)

# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2))
dim(textMatrix) = dim(moduleTraitCor)
#par(mar = c(3, 5, 2, 4));
#par(mar = c(3, 15, 2, 2));
#png(filename = "Module-Trait Relationship.png", width = 6, height = 14, res=400, unit="in")
par(mar = c(6, 20, 5, 5), cex = 0.525, pty = "m")
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = names(metadata_selected2),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = TRUE,
cex.text = 0.75,
zlim = c(-1,1),
main = paste("Module-trait relationships"),
font.lab.x = 3,
font.lab.y = 1)
#dev.off()
```

```{r}
gene_ids = colnames(resid_expr_test)
gene_ids = colnames(resid_expr_test)
# save(moduleColors, file = paste0(work_plots, "MyND/moduleColors.Rdata"))
gene_modules = cbind(gene_ids, moduleColors)
gene_modules = as.data.frame(gene_modules)
```

```{r}
## Get conversion table for Gencode 30
gencode_30 <- subset(gencode, select = c("gene_id", "gene_name"))
colnames(gencode_30) = c("ensembl","symbol")
gene_modules_symbol = merge(gene_modules, gencode_30, by.x = "gene_ids", by.y = "ensembl")
gene_modules_symbol <- unique(gene_modules_symbol)

# write.table(gene_modules_symbol, file = paste0(expr_dir, "MyND/geneBymodule.txt"), quote = F, row.names = F, sep = "\t")
#datatable(gene_modules_symbol)
```

Histogram of module sizes
```{r}
freq_table <- gene_modules_symbol %>%
  group_by(moduleColors) %>%
  summarise(moduleSize = n()) %>%
  arrange(desc(moduleSize))

# plot
freq_table  %>%
  ggplot( aes(x=moduleSize)) +
    geom_histogram( binwidth=100, fill="#69b3a2", color="#e9ecef", alpha=0.9) +
    theme(
      plot.title = element_text(size=10)
    ) + theme_classic() + ylab("Frequency")
```

Subset groups
```{r}
GBA_PD <- filter(meta, groups == "GBA_PD")
GBA_PD_matrix <- MEs[rownames(MEs) %in% GBA_PD$donor_id,]
GBA_PD_matrix$group <- "GBA_PD"

iPD <- filter(meta, groups == "iPD")
iPD_matrix <- MEs[rownames(MEs) %in% iPD$donor_id,]
iPD_matrix$group <- "iPD"

LRRK2_PD <- filter(meta, groups == "LRRK2_PD")
LRRK2_PD_matrix <- MEs[rownames(MEs) %in% LRRK2_PD$donor_id,]
LRRK2_PD_matrix$group <- "LRRK2_PD"

#all_PD <- filter(meta, Diagnosis == "PD")
#all_PD_matrix <- MEs[rownames(MEs) %in% all_PD$donor_id,]
#all_PD_matrix$group <- "all_PD"

Control <- filter(meta, groups == "Control")
Control_matrix <- MEs[rownames(MEs) %in% Control$donor_id,]
Control_matrix$group <- "Control"
```

```{r}
library(dplyr)
merged <- rbind(Control_matrix, iPD_matrix, GBA_PD_matrix, LRRK2_PD_matrix)

merged[["group"]] = factor(merged[["group"]], levels = c("Control", "iPD", "GBA_PD", "LRRK2_PD"))

merged <- merged %>% dplyr::select(group, everything())
```

```{r}
gba_class <- subset(meta, select = c("donor_id", "GBA_classification"))
sex_class <- subset(meta, select = c("donor_id", "Sex_reported"))
merged_plot <- rownames_to_column(merged, var = "donor_id")
merged_plot <- inner_join(gba_class, merged_plot, by = "donor_id")
merged_plot <- column_to_rownames(merged_plot, "donor_id")

merged_sex <- rownames_to_column(merged, var = "donor_id")
merged_sex <- inner_join(sex_class, merged_sex, by = "donor_id")
merged_sex <- column_to_rownames(merged_sex, "donor_id")
```

```{r}
library(rstatix)
stat.test <- merged_plot  %>%
  wilcox_test(MEdarkturquoise ~ group, paired = FALSE, p.adjust.method = "BH", comparisons = list(c("GBA_PD", "iPD"), c("GBA_PD", "LRRK2_PD"), c("LRRK2_PD", "iPD"), c("Control", "iPD"))) %>%
  add_significance()
stat.test
```

sig_MEs <- rbind(mediumpurple3, navajowhite2, blue, brown4, lightcyan1, thistle1, darkorange2, darkgrey, darkred, grey60, lightsteelblue1, steelblue, darkturquoise)
```{r}
library(ggpubr)
stat.test <- stat.test %>% add_xy_position(x = "group")
bxp <- ggboxplot(
  merged_plot, x = "group", y = "MEdarkturquoise", 
  ylab = "darkturquoise", xlab = "Groups", add = "jitter", color = "group", add.params = list(color = "GBA_classification")
  ) +   stat_pvalue_manual(stat.test,  label = "p", step.increase = .05)
bxp


#+  labs(subtitle = get_test_label(stat.test, detailed = TRUE))
```

```{r}
#ggsave(plot = bxp, filename = "/Users/ericabrophy/Documents/Allanalysis_results_121824_BioPD_Erica/WGCNA/boxplots/darkturquoise.pdf", width = 12, height = 8, units = "in")
```


```{r}
cols = colnames(merged)
  all.test <- NULL;
for (i in (2:ncol(merged))) {
        formula = as.formula( paste(cols[i], cols[1], sep="~") )
        #result <- wilcox_test(data=merged, formula=formula, paired=FALSE)
        
        
  stat.test <- merged  %>%
  wilcox_test(formula, p.adjust.method = "BH", paired = FALSE, comparisons = list(c("GBA_PD", "iPD"), c("GBA_PD", "LRRK2_PD"), c("LRRK2_PD", "iPD"), c("Control", "iPD"))) %>%
  add_significance()

  all.test <- rbind(all.test, stat.test)
  
        
}

```


```{r}
sig_ME_test <- filter(all.test, p < 0.05)
#sig_ME_test <- filter(all.test, p < != "ns")


mediumpurple3 <- filter(gene_modules_symbol, moduleColors == "mediumpurple3")
navajowhite2 <- filter(gene_modules_symbol, moduleColors == "navajowhite2")
blue <- filter(gene_modules_symbol, moduleColors == "blue")
brown4 <- filter(gene_modules_symbol, moduleColors == "brown4")
lightcyan1 <- filter(gene_modules_symbol, moduleColors == "lightcyan1")
thistle1 <- filter(gene_modules_symbol, moduleColors == "thistle1")
darkorange2 <- filter(gene_modules_symbol, moduleColors == "darkorange2")
darkgrey <- filter(gene_modules_symbol, moduleColors == "darkgrey")
darkred <- filter(gene_modules_symbol, moduleColors == "darkred")
grey60 <- filter(gene_modules_symbol, moduleColors == "grey60")
lightsteelblue1 <- filter(gene_modules_symbol, moduleColors == "lightsteelblue1")
steelblue <- filter(gene_modules_symbol, moduleColors == "steelblue")
darkturquoise <- filter(gene_modules_symbol, moduleColors == "darkturquoise")

sig_MEs <- rbind(mediumpurple3, navajowhite2, blue, brown4, lightcyan1, thistle1, darkorange2, darkgrey, darkred, grey60, lightsteelblue1, steelblue, darkturquoise)
table(sig_MEs$moduleColors)
#write_tsv(sig_MEs, "/Users/ericabrophy/Documents/sig_modules_14.tsv")
```


```{r}
# sig_MEs[["moduleColors"]] = factor(sig_MEs[["moduleColors"]], levels = c(  "magenta","lightcyan", "paleturquoise"))
# sig_MEs %>% as.data.frame %>%
#   group_by(moduleColors) %>% summarise(count=n()) %>%
#   ggplot(aes(x=moduleColors,y=count))+
#   geom_bar(stat = 'identity',color='black', fill=c("magenta", "paleturquoise","lightcyan"))+
#   scale_y_continuous(labels = scales::comma_format(accuracy = 2))+
#   geom_text(aes(label=count),vjust=-0.25,fontface='bold')+
#   theme_classic()+
#   theme(axis.text = element_text(color='black',face='bold')) + ggtitle("Significant Modules Gene Count: GBA PD vs iPD")
#write_tsv(sig_MEs, "/Users/ericabrophy/Documents/sig_MEs.tsv")
```

```{r}
library(WGCNA)
hub_genes <- chooseTopHubInEachModule(resid_expr_test, moduleColors, omitColors = "grey", power = 6, type = "signed") 
hub_genes <- as.data.frame(hub_genes)
hub_genes$module <- row.names(hub_genes)
hub_genes <- remove_rownames(hub_genes)
hub_genes$symbol <- gene_modules_symbol$symbol[ match(hub_genes$hub_genes, gene_modules_symbol$gene_ids)]
```


```{r}
sig_MEs_hub_genes <- filter(hub_genes, module == "mediumpurple3" | module == "navajowhite2" | module == "blue" | module == "brown4" | module == "lightcyan1"| module == "thistle1" | module == "darkorange2" | module == "darkgrey" | module == "darkred" | module == "grey60" | module == "lightsteelblue1"| module == "steelblue" | module == "darkturquoise")
```

```{r}
lm_merged <- filter(merged, group == "Control" | group == "iPD" | group == "LRRK2_PD")

x <-   ggplot(lm_merged, aes(group, MEnavajowhite2, colour = "group"))+
    geom_point(aes(color = group), position = position_jitter(seed = 42, width = 0.35)) +
   geom_smooth(method = lm, se = FALSE, linetype = "31", 
                aes(x = as.numeric(droplevels(as.factor(group))), MEnavajowhite2, color = "group")) + ggpubr::stat_cor(aes(x = as.numeric(droplevels(as.factor(group))), MEnavajowhite2), 
                      label.x = 0.5, label.y.npc = 0.9, size = 3) + theme_classic(base_size = 18)
x2 <- x + theme(legend.position = "none") + xlab("")
x2
```


```{r}
theme_paper <- function () { 
    theme_bw(base_size=7, base_family="Helvetica") %+replace% 
        theme(
          panel.grid = element_blank(),
          strip.background = element_blank(),
          #panel.border = element_blank(),
          axis.line = element_line(),
          axis.ticks = element_line(colour = "black"),
          #text = element_text(color = "black"), 
          strip.text = element_text(color = "black"),
          axis.text = element_text(colour = "black"),
            panel.background  = element_blank(),
            plot.background = element_rect(fill="white", colour=NA), 
            legend.background = element_rect(fill="transparent", colour=NA),
            legend.key = element_rect(fill="transparent", colour=NA), legend.text = element_text(size = 7), 
          legend.position = "top", legend.spacing.y  =  unit(0.001, 'cm')
        )
}
```
